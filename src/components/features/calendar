"use client";

import { useState } from 'react';
import type { BlogPost, GeminiPrompt } from '@/types/domains';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import { Badge } from '@/components/ui/badge';
import {
  Bot,
  Loader2,
  CheckCircle,
  AlertCircle,
  Copy,
  Download,
  Settings,
  Sparkles
} from 'lucide-react';

interface GeminiGeneratorProps {
  post: BlogPost;
  onGenerate: (content: string) => void;
  onSave: (post: BlogPost) => void;
  apiKey?: string;
  onApiKeyChange: (key: string) => void;
}

export function GeminiGenerator({
  post,
  onGenerate,
  onSave,
  apiKey,
  onApiKeyChange
}: GeminiGeneratorProps) {
  const [isGenerating, setIsGenerating] = useState(false);
  const [generatedContent, setGeneratedContent] = useState('');
  const [error, setError] = useState<string | null>(null);
  const [customPrompt, setCustomPrompt] = useState('');
  const [showSettings, setShowSettings] = useState(false);

  const defaultPrompts: GeminiPrompt[] = [
    {
      id: 'blog-post',
      name: 'Blog Post Generator',
      description: 'Generate a comprehensive blog post based on the title and keywords',
      prefix: 'Generate a blog post for the following scene: ',
      suffix: '. Make it engaging, informative, and SEO-optimized. Include headings, subheadings, and actionable tips.',
      variables: ['title', 'keywords', 'target_audience'],
      example: 'Generate a blog post for the following scene: How to Make a Music Video in 5 Minutes with AI. Make it engaging, informative, and SEO-optimized.',
      category: 'Blog Content'
    },
    {
      id: 'tutorial',
      name: 'Tutorial Generator',
      description: 'Generate step-by-step tutorial content',
      prefix: 'Create a detailed tutorial for: ',
      suffix: '. Include step-by-step instructions, tips, and common mistakes to avoid.',
      variables: ['title', 'skill_level'],
      example: 'Create a detailed tutorial for: How to Start a Faceless YouTube Channel. Include step-by-step instructions.',
      category: 'Tutorials'
    },
    {
      id: 'comparison',
      name: 'Comparison Generator',
      description: 'Generate comparison and review content',
      prefix: 'Write a comprehensive comparison article about: ',
      suffix: '. Include pros and cons, features, pricing, and recommendations.',
      variables: ['products', 'criteria'],
      example: 'Write a comprehensive comparison article about: Top 5 AI Music Video Generators. Include pros and cons.',
      category: 'Reviews'
    }
  ];

  const generatePrompt = (promptTemplate: GeminiPrompt) => {
    let prompt = promptTemplate.prefix;

    // Replace variables in the prompt
    prompt = prompt.replace('{title}', post.title);
    prompt = prompt.replace('{keywords}', post.keywords.join(', '));
    prompt = prompt.replace('{target_audience}', post.tags.join(', '));
    prompt = prompt.replace('{skill_level}', 'beginner to intermediate');

    prompt += promptTemplate.suffix;

    return prompt;
  };

  const generateContent = async (promptTemplate: GeminiPrompt) => {
    if (!apiKey) {
      setError('Please enter your Gemini API key in settings');
      return;
    }

    setIsGenerating(true);
    setError(null);

    try {
      const prompt = customPrompt || generatePrompt(promptTemplate);

      const response = await fetch('/api/gemini/generate', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          prompt,
          apiKey,
          post: {
            title: post.title,
            keywords: post.keywords,
            tags: post.tags,
            category: post.category,
            cluster: post.cluster
          }
        }),
      });

      if (!response.ok) {
        throw new Error('Failed to generate content');
      }

      const data = await response.json();
      setGeneratedContent(data.content);
      onGenerate(data.content);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to generate content');
    } finally {
      setIsGenerating(false);
    }
  };

  const copyToClipboard = async () => {
    try {
      await navigator.clipboard.writeText(generatedContent);
    } catch (err) {
      console.error('Failed to copy content:', err);
    }
  };

  const downloadContent = () => {
    const blob = new Blob([generatedContent], { type: 'text/markdown' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${post.slug}.md`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  const saveAsDraft = () => {
    const updatedPost = {
      ...post,
      content: generatedContent,
      excerpt: generatedContent.split('\n\n')[0] || generatedContent.substring(0, 200),
      status: 'draft' as const,
      updatedAt: new Date().toISOString()
    };
    onSave(updatedPost);
  };

  return (
    <div className="space-y-6">
      {/* POST INFO */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Bot className="w-5 h-5" />
            Generate Content for: {post.title}
          </CardTitle>
        </CardHeader>
        <CardContent>
          <div className="space-y-2">
            <div className="flex items-center gap-2">
              <Badge variant="outline">{post.category}</Badge>
              <Badge variant="outline">{post.priority} priority</Badge>
              <Badge variant="outline">Week {post.week}</Badge>
            </div>
            <div className="text-sm text-muted-foreground">
              <p><strong>Keywords:</strong> {post.keywords.join(', ')}</p>
              <p><strong>Tags:</strong> {post.tags.join(', ')}</p>
              <p><strong>Scheduled:</strong> {new Date(post.scheduledFor || post.publishedAt).toLocaleDateString()}</p>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* PROMPT SELECTION */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center justify-between">
            <span>Choose Generation Method</span>
            <Button
              variant="outline"
              size="sm"
              onClick={() => setShowSettings(!showSettings)}
            >
              <Settings className="w-4 h-4 mr-2" />
              Settings
            </Button>
          </CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          {showSettings && (
            <div className="p-4 border rounded-lg bg-muted/50">
              <Label htmlFor="apiKey">Gemini API Key</Label>
              <Input
                id="apiKey"
                type="password"
                value={apiKey || ''}
                onChange={(e) => onApiKeyChange(e.target.value)}
                placeholder="Enter your Gemini API key"
                className="mb-4"
              />
            </div>
          )}

          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
            {defaultPrompts.map((prompt) => (
              <Card key={prompt.id} className="cursor-pointer hover:shadow-md transition-shadow">
                <CardContent className="p-4">
                  <h3 className="font-semibold mb-2">{prompt.name}</h3>
                  <p className="text-sm text-muted-foreground mb-3">{prompt.description}</p>
                  <Button
                    size="sm"
                    className="w-full"
                    onClick={() => generateContent(prompt)}
                    disabled={isGenerating}
                  >
                    {isGenerating ? (
                      <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                    ) : (
                      <Sparkles className="w-4 h-4 mr-2" />
                    )}
                    Generate
                  </Button>
                </CardContent>
              </Card>
            ))}
          </div>

          <div>
            <Label htmlFor="customPrompt">Custom Prompt (Optional)</Label>
            <Textarea
              id="customPrompt"
              value={customPrompt}
              onChange={(e) => setCustomPrompt(e.target.value)}
              placeholder="Enter your custom prompt here..."
              rows={3}
              className="mt-2"
            />
          </div>
        </CardContent>
      </Card>

      {/* GENERATED CONTENT */}
      {generatedContent && (
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <CheckCircle className="w-5 h-5 text-green-600" />
              Generated Content
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="space-y-4">
              <div className="flex items-center gap-2">
                <Button size="sm" variant="outline" onClick={copyToClipboard}>
                  <Copy className="w-4 h-4 mr-2" />
                  Copy
                </Button>
                <Button size="sm" variant="outline" onClick={downloadContent}>
                  <Download className="w-4 h-4 mr-2" />
                  Download
                </Button>
                <Button size="sm" onClick={saveAsDraft}>
                  Save as Draft
                </Button>
              </div>

              <div className="border rounded-lg p-4 bg-muted/20 max-h-96 overflow-y-auto">
                <pre className="whitespace-pre-wrap text-sm">{generatedContent}</pre>
              </div>
            </div>
          </CardContent>
        </Card>
      )}

      {/* ERROR MESSAGE */}
      {error && (
        <Card className="border-red-200 bg-red-50">
          <CardContent className="p-4">
            <div className="flex items-center gap-2 text-red-800">
              <AlertCircle className="w-4 h-4" />
              <span>{error}</span>
            </div>
          </CardContent>
        </Card>
      )}
    </div>
  );
}
